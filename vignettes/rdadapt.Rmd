---
title: "Vignette package rdadapt v1.0"
author: "Thibaut Capblancq & Maya Gueguen"
date: "2024"
output:
  html_document:
    theme: sandstone
    highlight: tango
    fig_caption: true
    toc: true
    toc_float: true
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<br>

rdadapt was developed to facilitate the exploration and projection of the gene \~ environment relationship across current and future landscapes. The packages provides various statistical tools to conduct landscape genomics analyses going from identifying the the genetic bases of adaptation within a species to predict future population maldaptation to climate change.

In the following, we show how the rdadapt package can perform variance partitioning, genome scans for selection, adaptive index projection on the landscape, as well as estimation of genomic offsets and identification of co-varying modules of adaptive loci or discrete adaptive groups of individual or populations.

These analyses were inspired from various studies:

-   

    ```         
      Capblancq et al. 2018
    ```

-   

    ```         
      Forester et al. 2018
    ```

-   

    ```         
      Capblancq et al. 2020
    ```

-   

    ```         
      Capblancq & Forester 2021
    ```

-   

    ```         
      Capblancq et al. 2023
    ```

-   

    ```         
      Hoste et al. 2023
    ```

We show how to run the package using XXX

To run the package, you need to install the package and load it using the following command lines:

```{r, message=FALSE, results='hide', eval=TRUE}
install.packages("rdadapt")
library(rdadapt)
```

<br>

<h2>

1.  Loading and formatting data

    </h2>

    <br>

<h4>1.1. Genetic dataset</h4>

The genomic data used to search for adaptive loci consisted of 32,407 SNPs genotyped using the AdapTree project lodgepole pine 50K SNP array ([Mahony et al. 2020](https://onlinelibrary.wiley.com/doi/full/10.1111/eva.12871)).

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE}
## Loading genetic dataset
Y <- read.csv2("../data/genome.csv", sep = ",", head = TRUE, row.names = 1)
```

```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=FALSE}
Y[1:5,1:5]
```

We need

**Note:** Switching

The XXX <br>

<h4>1.2. Metadata individuals and populations</h4>

The

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE}
## Get population labels
pop <- read.csv2("../data/pop.csv", sep = ",", head = TRUE)[,-1]

## Get individual coordinates
coord <- read.csv2("../data/position.csv", sep = ",", head = TRUE)[,-1]
plot(coord, cex =.2)

```

<h4>1.3. Climatic variables</h4>

The values of XXX

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE}
## Loading the current and future climatic variables
xx.current <- read.table("../data/var_current.csv", sep = ",", head = TRUE, row.names = 1)
xx.future <- read.table("../data/var_futur.csv", sep = ",", head = TRUE, row.names = 1)

## Add exxtra variables (correlated)
xx.current <- data.frame(xx.current,VAR3 = 2*xx.current[,1] - xx.current[,2] + rnorm(nrow(xx.current), sd = 0.07), VAR4 = xx.current[,1] + xx.current[,2] + rnorm(nrow(xx.current), sd = 0.08))
xx.future <- data.frame(xx.future,VAR3 = 2*xx.future[,1] - xx.future[,2] + rnorm(nrow(xx.future), sd = 0.07), VAR4 = xx.future[,1] + xx.future[,2] + rnorm(nrow(xx.future), sd = 0.08))

# Rasterize the variables
xx.ras.current <- rast(data.frame(x = rep(1:10, time = 10), y = rep(1:10, each = 10), aggregate(xx.current, by = list(pop), mean)[,-1]), type="xyz")
xx.ras.future <- rast(data.frame(x = rep(1:10, time = 10),y = rep(1:10, each = 10), aggregate(xx.future, by = list(pop), mean)[,-1]), type="xyz")
```
```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=FALSE}
xx.current[1:5,]
xx.future[1:5,]
```
A perfect

<br>

```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=FALSE}
traits[1:5,1:6]
```

<br>

<h4>1.4. Inferring population structure</h4>

To account for population structure in some of the following RDA-based procedures we conducted a principal component analysis (PCA) on the set of 3,934 intergenic SNPs and retained the first three PCs as proxy of population evolutionary history.

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE}
## Loading the intergenic SNPs dataset
Neutral <- XXX
```

**Note:** No filtering on MAF was applied here because small genetic variations are expected to be involved in differentiating neutral genetic groups.

The PCA was then conducted on this neutral genetic matrix.

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE}
## Running a PCA on neutral genetic markers
pca <- rda(AllFreq_neutral[,-1], scale=T) # PCA in vegan uses the rda() call without any predictors
```

Screeplot of the PCA eigenvalues:

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE}
screeplot(pca, type = "barplot", npcs=10, main="PCA Eigenvalues")
```

Based on the screeplot, two or three PCs would be a reasonable set to retain as a proxy for neutral population structure in downstream analyses. In this case, we decided to keep the first three PCs.

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE}
## Neutral population structure table
PCs <- scores(pca, choices=c(1:3), display="sites", scaling=0)
PopStruct <- data.frame(Population = AllFreq_neutral[,1], PCs)
colnames(PopStruct) <- c("Population", "PC1", "PC2", "PC3")
```

```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=FALSE}
PopStruct[1:5,]
```

<br>

<h4>1.5. Merging all variables into a single table + loading mapping features</h4>

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE}
## Table gathering all variables
Variables <- data.frame(Coordinates, PopStruct[,-1], Env, traits)
```

```{r, message=FALSE, warning=FALSE, eval=TRUE, echo=FALSE}
Variables[1:5,]
```

For our analyses we focused on the geographic area occupied by lodgepole pine and used the species range to mask our projections.

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE}
## Administrative boundaries
admin <- ne_countries(scale = "medium", returnclass = "sf")

## Species range shapefile (download information at beginning of tutorial)
range <- readOGR("./Data/pinucon/pinucont.shp") 
crs(range) <- '+proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs'
```

<br>

<h2>

2.  Variable selection: forward model building procedure

    </h2>

    <br>

Forward selection starts from a "null" model where the response is explained only by an intercept. Variables are then added to the model one by one to try to reach the amount of variance explained by a "full" model (i.e., model including all the explanatory variables), while limiting the amount of redundancy among included variables.

```{r, message=FALSE, results='hide', eval=TRUE}
## Null model
RDA0 <- rda(AllFreq ~ 1,  Variables) 

## Full model
RDAfull <- rda(AllFreq ~ AHM + bFFP + CMD + DD_0 + DD_18 + DD18 + DD5 + eFFP + EMT + Eref + EXT + FFP + MAP + MAR + MAT + MCMT + MSP + MWMT + NFFD + PAS + PPT_sm + PPT_wt + RH + SHM + Tave_sm + Tave_wt + TD, Variables)
```

To conduct the selection procedure we used the ordiR2step function of the package vegan and the following stopping criteria: variable significance of p \< 0.01 using 1000 permutations, and the adjusted R2 of the global model.

```{r, message=FALSE, results='hide', eval=TRUE}
## Stepwise procedure with ordiR2step function
mod <- ordiR2step(RDA0, RDAfull, Pin = 0.01, R2permutations = 1000, R2scope = T)
```

```{r, message=FALSE, eval=TRUE, echo=FALSE}
mod$anova
```

In total, nine of the 27 bioclimate variables were selected: MAR, EMT, MWMT, CMD, Tave_wt, DD_18, MAP, Eref and PAS.

**Notes on interpretation and best practices:** We remind users that this predictive approach to variable selection optimizes the variance explained, but does not necessarily identify the ecological or mechanistic drivers of genetic variation. Additionally, pairwise predictor correlations can be very high, e.g., among seasonal calculations of temperature or precipitation. While one variable may maximize variance explained, it may be another, correlated variable, potentially even unmeasured, that is the mechanistic driver of variation. The ubiquitous nature of environmental correlation means that it is critical to carefully investigate selected variables but also avoid overinterpretation of variable importance in downstream analyses unless mechanistic data support observed relationships.

<br>

<h2>

3.  Variance partitioning: disentangling the drivers of genetic variation

    </h2>

    <br>

Variance partitioning with partial RDA (pRDA) can identify the contribution of different factors to reducing gene flow and triggering genetic divergence among populations. We apply pRDA-based variance partitioning to the lodgepole pine data to decompose the contribution of climate, neutral population structure, and geography in explaining genetic variation. We used three sets of variables: 1) the nine selected bioclimate variables (‘clim’); 2) three proxies of neutral genetic structure (population scores along the first three axes of a genetic PCA conducted on the 3,934 neutral loci; ‘struct’); and 3) population coordinates (longitude and latitude) to characterize geographic variation (‘geog’).

```{r, message=TRUE, echo=TRUE, eval=TRUE}
## Full model
pRDAfull <- rda(AllFreq ~ PC1 + PC2 + PC3 + Longitude + Latitude + MAR + EMT + MWMT + CMD + Tave_wt + DD_18 + MAP + Eref + PAS,  Variables)
RsquareAdj(pRDAfull)
anova(pRDAfull)
```

```{r, message=TRUE, echo=TRUE, eval=TRUE}
## Pure climate model
pRDAclim <- rda(AllFreq ~ MAR + EMT + MWMT + CMD + Tave_wt + DD_18 + MAP + Eref + PAS + Condition(Longitude + Latitude + PC1 + PC2 + PC3),  Variables)
RsquareAdj(pRDAclim)
anova(pRDAclim)
```

```{r, message=TRUE, echo=TRUE, eval=TRUE}
## Pure neutral population structure model  
pRDAstruct <- rda(AllFreq ~ PC1 + PC2 + PC3 + Condition(Longitude + Latitude + MAR + EMT + MWMT + CMD + Tave_wt + DD_18 + MAP + Eref + PAS),  Variables)
RsquareAdj(pRDAstruct)
anova(pRDAstruct)
```

```{r, message=TRUE, echo=TRUE, eval=TRUE}
##Pure geography model 
pRDAgeog <- rda(AllFreq ~ Longitude + Latitude + Condition(MAR + EMT + MWMT + CMD + Tave_wt + DD_18 + MAP + Eref + PAS + PC1 + PC2 + PC3),  Variables)
RsquareAdj(pRDAgeog)
anova(pRDAgeog)
```

To replicate Table 2 in the manuscript, we extract the following from the above results:

-   Total inertia (aka variance)
-   Constrained inertia
-   Proportion of variance explained by constraints
-   Model R^2^
-   Model p-value

**Note:** It is interesting to look at the degree of correlation among variables using a correlogram: <br>

```{r, message=TRUE, eval=TRUE, echo=FALSE, fig.align='center'}
corrplot(cor(Variables[, c("PC1","PC2","PC3","Longitude","Latitude","MAR","EMT","MWMT","CMD","Tave_wt","DD_18","MAP","Eref","PAS")]), type="upper")
```

<br>

**Notes on interpretation and best practices:** In this case, the largest proportion of genetic variance could not be uniquely attributed to any of the three sets of predictors, a common occurrence given the ubiquitous nature of spatial autocorrelation in environmental and genetic data sets. This confounded effect reflects a high degree of collinearity among explanatory variables. This is critical information given that most landscape genomic studies look for correlation between climatic and genetic variation (i.e., GEA) and either assume no collinearity or, on the contrary, totally remove this commonly explained variation. In the first case, GEA detections could potentially be subject to high false positive rates, while in the latter case detections might show high false negative rates. Selecting an appropriate approach to account for demographic history and geographic distance is of major importance when searching for selection in the genome. Variance partitioning can be a useful step to explore the (statistical) association among available descriptors, to better understand the covariation of environmental and genetic gradients, and to determine how much overall genetic variation is shaped by environmental, geographic, and demographic factors before conducting further landscape genomics study.

<h2>

4.  Genotype-Environment Associations: identifying loci under selection

    </h2>

    <br>

We used a pRDA to identify candidate adaptive markers in the lodgepole pine data using population allele frequencies for the 28,659 loci as response and the 9 selected bioclimate variables as predictors. We followed the procedure described in Capblancq et al. (2018) where outliers are identified based on their extremeness along a distribution of Mahalanobis distances estimated between each locus and the center of the RDA space using a certain number of axes (K).

Another option for identifying RDA outliers is to search for extreme loadings on each retained axis (e.g., Forester et al., 2018; [vignette and code](https://popgen.nescent.org/2018-03-27_RDA_GEA.html)).

<h4>4.1 Conducting the genome scan using pRDA</h4>

The first step was to run an RDA model on the allele frequency matrix using the 9 retained climatic factors as explanatory variables and the first three PCs as conditioning variables to account for neutral population structure.

```{r, message=FALSE, results='hide', eval=TRUE}
RDA_env <- rda(AllFreq ~ MAR + EMT + MWMT + CMD + Tave_wt + DD_18 + MAP + Eref + PAS + Condition(PC1 + PC2 + PC3),  Variables)
```

We then had to choose a number of RDA axes to include when conducting the genome scan.

```{r, message=FALSE, results='hide', eval=TRUE, fig.align='center'}
screeplot(RDA_env, main="Eigenvalues of constrained axes")
```

Looking at the proportion of variance explained by each axis, we decided to use the first two axes in this demonstration, though retaining just the first axis, or axes 1-3 would be other reasonable choices. If selecting only one axis, the [axis-based approach](https://popgen.nescent.org/2018-03-27_RDA_GEA.html) mentioned above would be required to identify outliers.

**Note:** It can be interesting to calculate the proportion of variance explained by the RDA model and the individual RDA axes when conducting a GEA test (code available [here](https://popgen.nescent.org/2018-03-27_RDA_GEA.html)); however having a high proportion of variance explained is not required for GEA testing, which is focused on identifying outlier loci in the ordination space, not maximizing variance explained.

For the lodgepole pine data, we will load the [rdadapt](XXX) function, described in Capblancq et al. (2018) and use it to conduct the genome scan.

```{r, message=FALSE, results='hide', eval=TRUE}
## Function rdadapt
source("./src/rdadapt.R")

## Running the function with K = 2
rdadapt_env<-rdadapt(RDA_env, 2)
```

One critical step when conducting a genome scan is to set a pertinent p-value threshold to identify the outlier loci. Here, we used a Bonferroni correction to account for multiple testing.

**Note:** the rdadapt function returns both p-values and q-values, which means it is possible to use a FDR (False Discovery Rate) approach instead of a p-value threshold to identify outliers; see [Francois et al. 2015](https://onlinelibrary.wiley.com/doi/full/10.1111/mec.13513).

```{r, message=FALSE, results='hide', eval=TRUE}
## P-values threshold after Bonferroni correction
thres_env <- 0.01/length(rdadapt_env$p.values)

## Identifying the loci that are below the p-value threshold
outliers <- data.frame(Loci = colnames(AllFreq)[which(rdadapt_env$p.values<thres_env)], p.value = rdadapt_env$p.values[which(rdadapt_env$p.values<thres_env)], contig = unlist(lapply(strsplit(colnames(AllFreq)[which(rdadapt_env$p.values<thres_env)], split = "_"), function(x) x[1])))
```

To avoid redundancy among loci that are in strong physical linkage along the genome we only kept the outlier locus with the lowest p-values for each genomic contig.

**Note:** To avoid linkage disequilibrium among loci, it is also possible to prune the dataset before running the genome scan. Here we preferred not to to be able to compare our top hit outliers with previously found adaptive loci that were searched for on a non-pruned dataset.

```{r, message=FALSE, results='hide', eval=TRUE}
## Top hit outlier per contig
outliers <- outliers[order(outliers$contig, outliers$p.value),]

## List of outlier names
outliers_rdadapt_env <- as.character(outliers$Loci[!duplicated(outliers$contig)])
```

Once the outliers have been identified, it can be useful to visualize their distribution in comparison with neutral loci using either an RDA biplot or a Manhattan plot.

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE, fig.align='center'}
## Formatting table for ggplot
locus_scores <- scores(RDA_env, choices=c(1:2), display="species", scaling="none") # vegan references "species", here these are the loci
TAB_loci <- data.frame(names = row.names(locus_scores), locus_scores)
TAB_loci$type <- "Neutral"
TAB_loci$type[TAB_loci$names%in%outliers$Loci] <- "All outliers"
TAB_loci$type[TAB_loci$names%in%outliers_rdadapt_env] <- "Top outliers"
TAB_loci$type <- factor(TAB_loci$type, levels = c("Neutral", "All outliers", "Top outliers"))
TAB_loci <- TAB_loci[order(TAB_loci$type),]
TAB_var <- as.data.frame(scores(RDA_env, choices=c(1,2), display="bp")) # pull the biplot scores

## Biplot of RDA loci and variables scores
ggplot() +
  geom_hline(yintercept=0, linetype="dashed", color = gray(.80), size=0.6) +
  geom_vline(xintercept=0, linetype="dashed", color = gray(.80), size=0.6) +
  geom_point(data = TAB_loci, aes(x=RDA1*20, y=RDA2*20, colour = type), size = 1.4) +
  scale_color_manual(values = c("gray90", "#F9A242FF", "#6B4596FF")) +
  geom_segment(data = TAB_var, aes(xend=RDA1, yend=RDA2, x=0, y=0), colour="black", size=0.15, linetype=1, arrow=arrow(length = unit(0.02, "npc"))) +
  geom_text(data = TAB_var, aes(x=1.1*RDA1, y=1.1*RDA2, label = row.names(TAB_var)), size = 2.5, family = "Times") +
  xlab("RDA 1") + ylab("RDA 2") +
  facet_wrap(~"RDA space") +
  guides(color=guide_legend(title="Locus type")) +
  theme_bw(base_size = 11, base_family = "Times") +
  theme(panel.background = element_blank(), legend.background = element_blank(), panel.grid = element_blank(), plot.background = element_blank(), legend.text=element_text(size=rel(.8)), strip.text = element_text(size=11))

## Manhattan plot
Outliers <- rep("Neutral", length(colnames(AllFreq)))
Outliers[colnames(AllFreq)%in%outliers$Loci] <- "All outliers"
Outliers[colnames(AllFreq)%in%outliers_rdadapt_env] <- "Top outliers"
Outliers <- factor(Outliers, levels = c("Neutral", "All outliers", "Top outliers"))
TAB_manhatan <- data.frame(pos = 1:length(colnames(AllFreq)), 
                           pvalues = rdadapt_env$p.values, 
                           Outliers = Outliers)
TAB_manhatan <- TAB_manhatan[order(TAB_manhatan$Outliers),]
ggplot(data = TAB_manhatan) +
  geom_point(aes(x=pos, y=-log10(pvalues), col = Outliers), size=1.4) +
  scale_color_manual(values = c("gray90", "#F9A242FF", "#6B4596FF")) +
  xlab("Loci") + ylab("-log10(p.values)") +
  geom_hline(yintercept=-log10(thres_env), linetype="dashed", color = gray(.80), size=0.6) +
  facet_wrap(~"Manhattan plot", nrow = 3) +
  guides(color=guide_legend(title="Locus type")) +
  theme_bw(base_size = 11, base_family = "Times") +
  theme(legend.position="right", legend.background = element_blank(), panel.grid = element_blank(), legend.box.background = element_blank(), plot.background = element_blank(), panel.background = element_blank(), legend.text=element_text(size=rel(.8)), strip.text = element_text(size=11))
```

We identified 557 loci showing extreme association with the environment, reduced to a set of 171 unlinked outliers when retaining only the best hit for each genomic contig.

<br>

<h4>4.2. Comparing outlier list to Mahony et al. (2020)</h4>

Among the 171 best hit outliers identified using pRDA (see above), 122 were also identified by Mahony et al. (2020) using Bayenv2, and a third (319) of the 865 loci identified with Bayenv2 were identified in the larger set of 557 RDA candidates.

```{r, message=FALSE, results='hide', eval=TRUE}
## Loading previously identified outliers
outliers_mahony <- read.table("./Data/gea_outliers_by_env_Mahonyetal2020.txt", header = T, row.names = 1)
outliers_mahony_env <- row.names(outliers_mahony)[apply(outliers_mahony[,3:21], 1, function(x) any(as.logical(x)))]
list_outliers <- list(RDA_best = outliers_rdadapt_env, RDA_all = as.character(outliers$Loci), Bayenv2 = outliers_mahony_env)
```

```{r, message=FALSE, eval=TRUE, echo=FALSE, fig.align='center'}
ggVennDiagram(list_outliers, category.names = c("RDA best hit", "RDA all", "Bayenv2"), lty="solid", color="black", size=0.2) + 
  scale_fill_gradient2(low = "white", high = 'gray40') + scale_color_manual(values = c("grey", "grey", "grey", "grey")) + guides(fill = "none") + theme(text = element_text(size=16, family = "Times"))
```

<br>

<h4>4.3. Not accounting for population structure</h4>

In this example, we accounted for population structure, as is commonly recommended when conducting genome scans; however, there are cases where this approach can be overly conservative. To investigate this issue in the lodgepole pine data, we compared the candidates identified with the partial RDA to those identified using a simple RDA.

```{r, message=FALSE, results='hide', eval=TRUE, fig.align='center'}
## Running a simple RDA model
RDA_env_unconstrained <- rda(AllFreq ~ MAR + EMT + MWMT + CMD + Tave_wt + DD_18 + MAP + Eref + PAS,  Variables)
 
## Running the rdadapt function
rdadapt_env_unconstrained <- rdadapt(RDA_env_unconstrained, 2)

## Setting the p-value threshold 
thres_env <- 0.01/length(rdadapt_env_unconstrained$p.values)

## Identifying the outliers for the simple RDA
outliers_unconstrained <- data.frame(Loci = colnames(AllFreq)[which(rdadapt_env_unconstrained$p.values<thres_env)], p.value = rdadapt_env_unconstrained$p.values[which(rdadapt_env_unconstrained$p.values<thres_env)], contig = unlist(lapply(strsplit(colnames(AllFreq)[which(rdadapt_env_unconstrained$p.values<thres_env)], split = "_"), function(x) x[1])))
outliers_unconstrained <- outliers_unconstrained[order(outliers_unconstrained$contig, outliers_unconstrained$p.value),]
outliers_rdadapt_env_unconstrained <- as.character(outliers_unconstrained$Loci[!duplicated(outliers_unconstrained$contig)])
```

We then compared the outliers identified when accounting or not for population structure.

```{r, message=FALSE, results='hide', eval=TRUE, fig.align='center'}
## For all the outliers
list_outliers_RDA_all <- list(RDA_constrained = as.character(outliers$Loci), RDA_unconstrained = as.character(outliers_unconstrained$Loci))
ggVennDiagram(list_outliers_RDA_all, category.names = c("partial RDA", "simple RDA"), lty="solid", size=0.2) + 
  scale_fill_gradient2(low = "white", high = 'gray40') + scale_color_manual(values = c("grey", "grey", "grey", "grey")) + guides(fill = "none") + theme(text = element_text(size=16, family = "Times"))

## Only for the top hit locus per contig
list_outliers_RDA_top <- list(RDA_constrained = outliers_rdadapt_env, RDA_unconstrained = outliers_rdadapt_env_unconstrained)
ggVennDiagram(list_outliers_RDA_top, category.names = c("partial RDA", "simple RDA"), lty="solid", size=0.2) + 
  scale_fill_gradient2(low = "white", high = 'gray40') + scale_color_manual(values = c("grey", "grey", "grey", "grey")) + guides(fill = "none") + theme(text = element_text(size=16, family = "Times"))
```

For all of the following RDA-based analyses we decided to retain only the 91 loci that were detected by both the partial RDA that accounted for population structure and by the simple RDA that did not account for population structure.

```{r, message=FALSE, results='hide', eval=TRUE}
common_outliers_RDA_top <- Reduce(intersect, list_outliers_RDA_top)
```

**Notes on interpretation and best practices:** We emphasize that there is no correct answer to the common dilemma of confounded variation in GEA, differentiation-based, and genome-wide association analyses. Instead, researchers must balance their tolerance for false negative and false positive rates, and use an analytical approach that best matches the objectives of the study as well as the potential ability to validate candidate loci. More generally, awareness of the tradeoffs associated with decisions such as population structure correction will allow users to appropriately interpret their results, both statistically and biologically. Decisions about if and how to correct for population structure, how to set outlier thresholds, and how to finalize a set of candidate adaptive markers will depend upon the objectives of the study and the data available (if any) for validation. The approach presented here is not meant to be applied without modification; modeling parameters (including what environmental predictors are used and how they are selected, see variable selection above) and other decisions should be determined based on the ecology of the organism, characteristics of the data set, and goals of the study.

<br>

<h2>

5.  Adaptive landscape: projecting adaptive gradient(s) across space

    </h2>

    <br>

<h4>5.1. Adaptively enriched genetic space</h4>

The 91 putative adaptive loci were used as multivariate response in a new “adaptively enriched” RDA, using the 9 selected bioclimate variables as explanatory variables.

```{r, message=FALSE, results='hide', eval=TRUE}
## Adaptively enriched RDA
RDA_outliers <- rda(AllFreq[,common_outliers_RDA_top] ~ MAR + EMT + MWMT + CMD + Tave_wt + DD_18 + MAP + Eref + PAS,  Variables)
```

An RDA biplot allows us to visualize the relationship between the 91 putative adaptive loci and the underlying climatic variables.

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE, fig.align='center'}
## RDA biplot
TAB_loci <- as.data.frame(scores(RDA_outliers, choices=c(1:2), display="species", scaling="none"))
TAB_var <- as.data.frame(scores(RDA_outliers, choices=c(1:2), display="bp"))
ggplot() +
  geom_hline(yintercept=0, linetype="dashed", color = gray(.80), size=0.6) +
  geom_vline(xintercept=0, linetype="dashed", color = gray(.80), size=0.6) +
  geom_point(data = TAB_loci, aes(x=RDA1*3, y=RDA2*3), colour = "#EB8055FF", size = 2, alpha = 0.8) + #"#F9A242FF"
  geom_segment(data = TAB_var, aes(xend=RDA1, yend=RDA2, x=0, y=0), colour="black", size=0.15, linetype=1, arrow=arrow(length = unit(0.02, "npc"))) +
  geom_text(data = TAB_var, aes(x=1.1*RDA1, y=1.1*RDA2, label = row.names(TAB_var)), size = 2.5, family = "Times") +
  xlab("RDA 1 (67%)") + ylab("RDA 2 (21%)") +
  facet_wrap(~"Adaptively enriched RDA space") +
  guides(color=guide_legend(title="Locus type")) +
  theme_bw(base_size = 11, base_family = "Times") +
  theme(panel.grid = element_blank(), plot.background = element_blank(), panel.background = element_blank(), strip.text = element_text(size=11))
```

<br>

<h4>5.2. Adaptive index across the landscape</h4>

The scores of the environmental variables along the RDA axes can be used to calculate a genetic-based index of adaptation for each environmental pixel of the landscape. This index is estimated independently for each RDA axis of interest using the formula: $$
\sum_{i = 1}^{n}{a_ib_i}
$$ Where *a* is the climatic variable score (loading) along the RDA axis, *b* is the standardized value for this particular variable at the focal pixel, and *i* refers to one of the *n* different variables used in the RDA model.

```{r, message=FALSE, results='hide', eval=TRUE}
## Function to predict the adaptive index across the landscape
source("./src/adaptive_index.R")

## Running the function for all the climatic pixels of lodgepole pine distribution range
res_RDA_proj_current <- adaptive_index(RDA = RDA_outliers, K = 2, env_pres = ras_6190, range = range, method = "loadings", scale_env = scale_env, center_env = center_env)
```

The adaptive index thus provides an estimate of adaptive genetic similarity or difference of all pixels on the landscape as a function of the values of the environmental predictors at that location. When projected on a map it allows visualizing the different adaptive gradients across a species range.

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE, fig.align='center', fig.width=10}
## Vectorization of the climatic rasters for ggplot
RDA_proj <- list(res_RDA_proj_current$RDA1, res_RDA_proj_current$RDA2)
RDA_proj <- lapply(RDA_proj, function(x) rasterToPoints(x))
for(i in 1:length(RDA_proj)){
  RDA_proj[[i]][,3] <- (RDA_proj[[i]][,3]-min(RDA_proj[[i]][,3]))/(max(RDA_proj[[i]][,3])-min(RDA_proj[[i]][,3]))
}

## Adaptive genetic turnover projected across lodgepole pine range for RDA1 and RDA2 indexes
TAB_RDA <- as.data.frame(do.call(rbind, RDA_proj[1:2]))
colnames(TAB_RDA)[3] <- "value"
TAB_RDA$variable <- factor(c(rep("RDA1", nrow(RDA_proj[[1]])), rep("RDA2", nrow(RDA_proj[[2]]))), levels = c("RDA1","RDA2"))
ggplot(data = TAB_RDA) + 
  geom_sf(data = admin, fill=gray(.9), size=0) +
  geom_raster(aes(x = x, y = y, fill = cut(value, breaks=seq(0, 1, length.out=10), include.lowest = T))) + 
  scale_fill_viridis_d(alpha = 0.8, direction = -1, option = "A", labels = c("Negative scores","","","","Intermediate scores","","","","Positive scores")) +
  geom_sf(data = admin, fill=NA, size=0.1) +
  coord_sf(xlim = c(-148, -98), ylim = c(35, 64), expand = FALSE) +
  xlab("Longitude") + ylab("Latitude") +
  guides(fill=guide_legend(title="Adaptive index")) +
  facet_grid(~ variable) +
  theme_bw(base_size = 11, base_family = "Times") +
  theme(panel.grid = element_blank(), plot.background = element_blank(), panel.background = element_blank(), strip.text = element_text(size=11))
```

**Notes on interpretation and best practices:** We remind users that any prediction procedure such as this relies on the extrapolation of correlative relationships and carries potential pitfalls. Predicting any genetic-based adaptive index in unsampled areas could be strongly biased if the value or combination of the environmental predictors in those projected areas exceed those used to train the model. Similarly, any projection could be inaccurate if the genetic \~ environment relationship is not well characterized, either because the scale of the analyses (e.g., size of the pixel) does not capture the complexity of the association, or because the distribution of the identified genetic variation is not optimal across the current and/or future environmental landscape (e.g., due to recent demographic history, barriers to gene flow, genetic drift in small populations, fluctuating trait heritability, varying selection pressures, or genetic architecture). It is critical to avoid overinterpretation of adaptive index projections, especially when validation data are not available.

<br>

<h2>

6.  Predicting local maladaptation: genomic offset

    </h2>

    <br>

<h4>6.1. Predicting future genomic offset</h4>

Once the genetic \~ environment relationship is characterized, it can be extrapolated to future environments to predict a potential shift in adaptive optimum induced by climate change.The RDA-based method to predict this future maladaptation is relatively simple. As done above, RDA can be used to predict the optimal adaptive genetic composition for each environmental pixel under consideration (Adaptive Index in Section 5), using both current and future environmental conditions. The difference between the two predictions provides an estimate of the change in genetic composition that would be required to track climate change.

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE, fig.align='center', fig.width=10}
## Function to predict genomic offset from a RDA model
source("./src/genomic_offset.R")

## Running the function for 2050 and 2080
res_RDA_proj2080 <- genomic_offset(RDA_outliers, K = 2, env_pres = ras_6190, env_fut = ras_2080, range = range, method = "loadings", scale_env = scale_env, center_env = center_env)
res_RDA_proj2050 <- genomic_offset(RDA_outliers, K = 2, env_pres = ras_6190, env_fut = ras_2050, range = range, method = "loadings", scale_env = scale_env, center_env = center_env)

## Table global genetic offset predicted for 2050 and 2080
RDA_proj_offset <- data.frame(rbind(rasterToPoints(res_RDA_proj2050$Proj_offset_global), rasterToPoints(res_RDA_proj2080$Proj_offset_global)), Date = c(rep("2050", nrow(rasterToPoints(res_RDA_proj2050$Proj_offset_global))), rep("2080", nrow(rasterToPoints(res_RDA_proj2080$Proj_offset_global)))))

## Projecting genomic offset on a map
colors <- c(colorRampPalette(brewer.pal(11, "Spectral")[6:5])(2), colorRampPalette(brewer.pal(11, "Spectral")[4:3])(2), colorRampPalette(brewer.pal(11, "Spectral")[2:1])(3))
ggplot(data = RDA_proj_offset) + 
  geom_sf(data = admin, fill=gray(.9), size=0) +
  geom_raster(aes(x = x, y = y, fill = cut(Global_offset, breaks=seq(1, 8, by = 1), include.lowest = T)), alpha = 1) + 
  scale_fill_manual(values = colors, labels = c("1-2","2-3","3-4","4-5","5-6","6-7","7-8"), guide = guide_legend(title="Genomic offset", title.position = "top", title.hjust = 0.5, ncol = 1, label.position="right"), na.translate = F) +
  geom_sf(data = admin, fill=NA, size=0.1) +
  coord_sf(xlim = c(-148, -98), ylim = c(35, 64), expand = FALSE) +
  xlab("Longitude") + ylab("Latitude") +
  facet_grid(~ Date) +
  theme_bw(base_size = 11, base_family = "Times") +
  theme(panel.grid = element_blank(), plot.background = element_blank(), panel.background = element_blank(), strip.text = element_text(size=11))
```

<br>

<h4>6.2. Predicting geographic genomic offset</h4>

A challenge associated with any predictive method is to find ways to validate the predictions. Here, we took advantage of the common garden experiment conducted in lodgepole pine to test our genomic offset predictions. We estimated a geographic genomic offset between the climate of each source population (based on the average between 1960 and 1990) and the climate of the garden where the seedlings were grown (in Vancouver, BC, Canada, averaging the years 2012 to 2015) and were then able to test the influence of the predicted genomic offset on the seedling fitness traits.

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE, fig.align='center'}
env <- row.names(scores(RDA_outliers, choices=c(1:2), display="bp"))

## Environmental variables for the period the seedlings were growing in the common garden (2012-2015)
env_garden <- read.table("./Data/ClimateData_VancouverGarden.csv", sep = ",", header = T)
env_garden <- env_garden[, env]
env_garden$MAR <- extract(ras_6190[[env]]$MAR, c(-123.250, 49.256))[2]
env_garden <- as.data.frame(scale(env_garden, center = center_env[env], scale = scale_env[env]))
env_garden <- colMeans(env_garden)

## Environmental variables for the source populations between 61 and 90
env_provenance <- data.frame(extract(ras_6190[[env]], Variables[,c("Longitude", "Latitude")]))
env_provenance <- as.data.frame(scale(env_provenance, center_env[env], scale_env[env]))
row.names(env_provenance) <- Variables[,"Population"]
```

Based on the adaptively enriched RDA space, we estimated a distance between each source population and the common garden climatic conditions.

```{r, message=FALSE, results='hide', eval=TRUE, fig.align='center'}
## Function to estimate genetic offset between provenance and garden  
source("./src/provgar_offset.R")

## Running the provenance to garden genetic offset function
provgar_offset <- provgar_offset(RDA = RDA_outliers, K = 2, env_garden = env_garden, env_provenance = env_provenance, weights = TRUE)
```

This geographic genomic offset can then be compared to different fitness traits in the garden to estimate the impact of this predicted maladaptation on seedling fitness. We can also compare the influence of genomic offset on fitness with the impact of a basic climate transfer distance estimated between each source population and the garden from the climatic variables only (using Mahalanobis distance).

```{r, message=FALSE, results='hide', eval=TRUE, fig.align='center'}
## Climate distance between provenances and garden
tabmaha <- as.data.frame(rbind(env_garden, env_provenance))
mahaclim <- mahalanobis(as.matrix(tabmaha), center = as.numeric(tabmaha[1,]), cov = cov(as.matrix(tabmaha)))

## Comparison climate transfer vs. genomic offset impact on fitness
TAB_comp <- data.frame(x = rep(c(mahaclim[-1], provgar_offset[-1]), 2), y = c(rep(traits$Height, 2), rep(traits$GthRate, 2)), method = rep(rep(c("Climate", "Genetics"), each = nrow(traits)), 2), variable = rep(c("Final height", "Growth rate"), each = 2*nrow(traits)))
ggplot(TAB_comp, aes(x=x, y=y)) +
  geom_point(shape=19, size = 2, alpha = .7) +
  geom_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1) +
  facet_grid(variable ~ method, scales = "free") +
  ylab("Scaled fitness trait value") + 
  xlab("Climate transfer distance                              Genomic offset") +
  theme_bw(base_size = 12, base_family = "Times") +
  theme(panel.grid = element_blank(), panel.background = element_blank())
```

```{r, message=TRUE, eval=TRUE}
## Quadratic regression statistical testing
summary(lm(traits$Height ~ poly(mahaclim[-1])))
summary(lm(traits$Height ~ poly(provgar_offset[-1])))
summary(lm(traits$GthRate ~ poly(mahaclim[-1])))
summary(lm(traits$GthRate ~ poly(provgar_offset[-1])))
```

**Notes on interpretation and best practices:** We found that genomic offset better explained the decrease in height and growth rate than the basic climate transfer distance, which confirms the great potential of genomic offset for selecting source population for management or conservation plans. As with the adaptive index (previous section), when validation data are not available, it is critical to avoid overinterpretation of genomic offset projections given that they are based on statistical associations only.

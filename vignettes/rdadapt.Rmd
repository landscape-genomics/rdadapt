---
title: "Vignette package rdadapt v1.0"
author: "Thibaut Capblancq & Maya Gueguen"
date: "2024"
output:
  html_document:
    theme: sandstone
    highlight: tango
    fig_caption: true
    toc: true
    toc_float: true
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<br>

rdadapt was developed to facilitate the exploration and projection of the gene \~ environment relationship across current and future landscapes. The packages provides various statistical tools to conduct landscape genomics analyses going from identifying the the genetic bases of adaptation within a species to predict future population maldaptation to climate change.

In the following, we show how the rdadapt package can perform variance partitioning, genome scans for selection, adaptive index projection on the landscape, as well as estimation of genomic offsets and identification of co-varying modules of adaptive loci or discrete adaptive groups of individual or populations.

These analyses were inspired from various studies:

-   

    ```         
      Capblancq et al. 2018
    ```

-   

    ```         
      Forester et al. 2018
    ```

-   

    ```         
      Capblancq et al. 2020
    ```

-   

    ```         
      Capblancq & Forester 2021
    ```

-   

    ```         
      Capblancq et al. 2023
    ```

-   

    ```         
      Hoste et al. 2023
    ```

We show how to run the package using XXX

To run the package, you need to install the package and load it using the following command lines:

```{r, message=FALSE, results='hide', eval=TRUE}
#install.packages("rdadapt")
#library(rdadapt)
library(vegan)
library(robust)
library(ggplot2)
library(terra)
library(qvalue)
```

<br>

<h2>

1.  Loading and formatting data

    </h2>

    <br>

<h4>1.1. Genetic dataset</h4>

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE}
## Loading genetic dataset
Y <- read.csv2("../data/genome.csv", sep = ",", head = TRUE, row.names = 1)

Y[1:5,1:5]
```

<h4>1.2. Metadata individuals and populations</h4>

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE}
## Get population labels
pop <- read.csv2("../data/pop.csv", sep = ",", head = TRUE)[,-1]

## Get individual coordinates
coord <- read.csv2("../data/position.csv", sep = ",", head = TRUE)[,-1]
plot(coord, cex =.2)

```

<h4>1.3. Climatic variables</h4>

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE}
## Loading the current and future climatic variables
xx.current <- read.table("../data/var_current.csv", sep = ",", head = TRUE, row.names = 1)
xx.future <- read.table("../data/var_futur.csv", sep = ",", head = TRUE, row.names = 1)

## Add exxtra variables (correlated)
xx.current <- data.frame(xx.current,VAR3 = 2*xx.current[,1] - xx.current[,2] + rnorm(nrow(xx.current), sd = 0.07), VAR4 = xx.current[,1] + xx.current[,2] + rnorm(nrow(xx.current), sd = 0.08))
xx.future <- data.frame(xx.future,VAR3 = 2*xx.future[,1] - xx.future[,2] + rnorm(nrow(xx.future), sd = 0.07), VAR4 = xx.future[,1] + xx.future[,2] + rnorm(nrow(xx.future), sd = 0.08))

# Rasterize the variables
xx.ras.current <- rast(data.frame(x = rep(1:12, time = 12), 
                                  y = rep(1:12, each = 12), 
                                  aggregate(xx.current, by = list(ceiling(as.numeric(coord$x)), ceiling(as.numeric(coord$y))), mean)[,-c(1,2)]), 
                       type="xyz", 
                       crs = crs("epsg:4326"))
plot(xx.ras.current)

xx.ras.future <- rast(data.frame(x = rep(1:12, time = 12),
                                 y = rep(1:12, each = 12), 
                                 aggregate(xx.future, by = list(ceiling(as.numeric(coord$x)), ceiling(as.numeric(coord$y))), mean)[,-c(1,2)]), 
                      type="xyz", 
                      crs = crs("epsg:4326"))
plot(xx.ras.future)
```


4.  Genotype-Environment Associations: identifying loci under selection

    </h2>

    <br>

<h4>4.1 Conducting the genome scan using RDA</h4>

```{r, message=FALSE, results='hide', eval=TRUE}
RDA_env <- rda(Y ~ .,  xx.current)
plot(RDA_env)
```

We then had to choose a number of RDA axes to include when conducting the genome scan.

```{r, message=FALSE, results='hide', eval=TRUE, fig.align='center'}
screeplot(RDA_env, main="Eigenvalues of constrained axes")
```

Looking at the proportion of variance explained by each axis, we decided to use the first two axes.

```{r, message=FALSE, results='hide', eval=TRUE}
## Function rdadapt
source("../R/rdadapt.R")

## Running the function with K = 2
rdadapt_env<-rdadapt(RDA_env, 2)
```

One critical step when conducting a genome scan is to set a pertinent p-value threshold to identify the outlier loci. Here, we used a Bonferroni correction to account for multiple testing.

```{r, message=FALSE, results='hide', eval=TRUE}
## P-values threshold after Bonferroni correction
thres_env <- 0.01/length(rdadapt_env$p.values)

## Identifying the loci that are below the p-value threshold
outliers <- (1:ncol(Y))[which(rdadapt_env$p.values<thres_env)]
```

The function finds 215 outliers

```{r, message=FALSE, results='hide', eval=TRUE}
## Get adaptive loci for env variable 1 and env variable 2
causal1 <- as.numeric(read.csv2("../data/mutationm2.csv", sep = ",", head = TRUE)[,-1])
causal2 <- as.numeric(read.csv2("../data/mutationm3.csv", sep = ",", head = TRUE)[,-1])

## True positive ratio
sum(outliers %in% causal1 | outliers %in% causal2)/length(outliers)

## False negative ratio
sum(!(causal1 %in% outliers))+sum(!(causal2 %in% outliers))/(length(causal1)+length(causal2))

```

Once the outliers have been identified, it can be useful to visualize their distribution in comparison with neutral loci using either an RDA biplot or a Manhattan plot.

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE, fig.align='center'}
# ## Formatting table for ggplot
# locus_scores <- scores(RDA_env, choices=c(1:2), display="species", scaling="none") # vegan references "species", here these are the loci
# TAB_loci <- data.frame(names = row.names(locus_scores), locus_scores)
# TAB_loci$type <- "Neutral"
# TAB_loci$type[TAB_loci$names%in%outliers$Loci] <- "All outliers"
# TAB_loci$type[TAB_loci$names%in%outliers_rdadapt_env] <- "Top outliers"
# TAB_loci$type <- factor(TAB_loci$type, levels = c("Neutral", "All outliers", "Top outliers"))
# TAB_loci <- TAB_loci[order(TAB_loci$type),]
# TAB_var <- as.data.frame(scores(RDA_env, choices=c(1,2), display="bp")) # pull the biplot scores
# 
# ## Biplot of RDA loci and variables scores
# ggplot() +
#   geom_hline(yintercept=0, linetype="dashed", color = gray(.80), size=0.6) +
#   geom_vline(xintercept=0, linetype="dashed", color = gray(.80), size=0.6) +
#   geom_point(data = TAB_loci, aes(x=RDA1*20, y=RDA2*20, colour = type), size = 1.4) +
#   scale_color_manual(values = c("gray90", "#F9A242FF", "#6B4596FF")) +
#   geom_segment(data = TAB_var, aes(xend=RDA1, yend=RDA2, x=0, y=0), colour="black", size=0.15, linetype=1, arrow=arrow(length = unit(0.02, "npc"))) +
#   geom_text(data = TAB_var, aes(x=1.1*RDA1, y=1.1*RDA2, label = row.names(TAB_var)), size = 2.5, family = "Times") +
#   xlab("RDA 1") + ylab("RDA 2") +
#   facet_wrap(~"RDA space") +
#   guides(color=guide_legend(title="Locus type")) +
#   theme_bw(base_size = 11, base_family = "Times") +
#   theme(panel.background = element_blank(), legend.background = element_blank(), panel.grid = element_blank(), plot.background = element_blank(), legend.text=element_text(size=rel(.8)), strip.text = element_text(size=11))
# 
# ## Manhattan plot
# Outliers <- rep("Neutral", length(colnames(AllFreq)))
# Outliers[colnames(AllFreq)%in%outliers$Loci] <- "All outliers"
# Outliers[colnames(AllFreq)%in%outliers_rdadapt_env] <- "Top outliers"
# Outliers <- factor(Outliers, levels = c("Neutral", "All outliers", "Top outliers"))
# TAB_manhatan <- data.frame(pos = 1:length(colnames(AllFreq)), 
#                            pvalues = rdadapt_env$p.values, 
#                            Outliers = Outliers)
# TAB_manhatan <- TAB_manhatan[order(TAB_manhatan$Outliers),]
# ggplot(data = TAB_manhatan) +
#   geom_point(aes(x=pos, y=-log10(pvalues), col = Outliers), size=1.4) +
#   scale_color_manual(values = c("gray90", "#F9A242FF", "#6B4596FF")) +
#   xlab("Loci") + ylab("-log10(p.values)") +
#   geom_hline(yintercept=-log10(thres_env), linetype="dashed", color = gray(.80), size=0.6) +
#   facet_wrap(~"Manhattan plot", nrow = 3) +
#   guides(color=guide_legend(title="Locus type")) +
#   theme_bw(base_size = 11, base_family = "Times") +
#   theme(legend.position="right", legend.background = element_blank(), panel.grid = element_blank(), legend.box.background = element_blank(), plot.background = element_blank(), panel.background = element_blank(), legend.text=element_text(size=rel(.8)), strip.text = element_text(size=11))
```

<br>

<h2>

5.  Adaptive landscape: projecting adaptive gradient(s) across space

    </h2>

    <br>

<h4>5.1. Adaptively enriched genetic space</h4>

The 91 putative adaptive loci were used as multivariate response in a new “adaptively enriched” RDA, using the 9 selected bioclimate variables as explanatory variables.

```{r, message=FALSE, results='hide', eval=TRUE}
## Adaptively enriched RDA
RDA_outliers <- rda(Y[,outliers] ~ .,  xx.current)
```

An RDA biplot allows us to visualize the relationship between the 91 putative adaptive loci and the underlying climatic variables.

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE, fig.align='center'}
## RDA biplot
TAB_loci <- as.data.frame(scores(RDA_outliers, choices=c(1:2), display="species", scaling="none"))
TAB_var <- as.data.frame(scores(RDA_outliers, choices=c(1:2), display="bp"))
ggplot() +
  geom_hline(yintercept=0, linetype="dashed", color = gray(.80), size=0.6) +
  geom_vline(xintercept=0, linetype="dashed", color = gray(.80), size=0.6) +
  geom_point(data = TAB_loci, aes(x=RDA1*3, y=RDA2*3), colour = "#EB8055FF", size = 2, alpha = 0.8) + #"#F9A242FF"
  geom_segment(data = TAB_var, aes(xend=RDA1, yend=RDA2, x=0, y=0), colour="black", size=0.15, linetype=1, arrow=arrow(length = unit(0.02, "npc"))) +
  geom_text(data = TAB_var, aes(x=1.1*RDA1, y=1.1*RDA2, label = row.names(TAB_var)), size = 2.5, family = "Times") +
  xlab("RDA 1 (XX%)") + ylab("RDA 2 (XX%)") +
  facet_wrap(~"Adaptively enriched RDA space") +
  guides(color=guide_legend(title="Locus type")) +
  theme_bw(base_size = 11, base_family = "Times") +
  theme(panel.grid = element_blank(), plot.background = element_blank(), panel.background = element_blank(), strip.text = element_text(size=11))
```

<br>

<h4>5.2. Adaptive index across the landscape</h4>

The scores of the environmental variables along the RDA axes can be used to calculate a genetic-based index of adaptation for each environmental pixel of the landscape. This index is estimated independently for each RDA axis of interest using the formula: $$
\sum_{i = 1}^{n}{a_ib_i}
$$ Where *a* is the climatic variable score (loading) along the RDA axis, *b* is the standardized value for this particular variable at the focal pixel, and *i* refers to one of the *n* different variables used in the RDA model.

```{r, message=FALSE, results='hide', eval=TRUE}
## Function to predict the adaptive index across the landscape
source("../R/adaptive_index.R")

## Running the function for all pixels 
res_RDA_proj_current <- adaptive_index(RDA = RDA_outliers, K = 2, env_pres = xx.ras.current, range = NULL, method = "loadings", scale_env = NULL, center_env = NULL)
```

The adaptive index thus provides an estimate of adaptive genetic similarity or difference of all pixels on the landscape as a function of the values of the environmental predictors at that location. When projected on a map it allows visualizing the different adaptive gradients across a species range.

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE, fig.align='center', fig.width=10}
## Vectorization of the climatic rasters for ggplot
RDA_proj <- list(res_RDA_proj_current$RDA1, res_RDA_proj_current$RDA2)
RDA_proj <- lapply(RDA_proj, function(x) as.data.frame(x, xy = TRUE))
for(i in 1:length(RDA_proj)){
  RDA_proj[[i]][,3] <- (RDA_proj[[i]][,3]-min(RDA_proj[[i]][,3]))/(max(RDA_proj[[i]][,3])-min(RDA_proj[[i]][,3]))
  colnames(RDA_proj[[i]])[3] <- "value"
}

## Adaptive genetic turnover projected across lodgepole pine range for RDA1 and RDA2 indexes
TAB_RDA <- as.data.frame(do.call(rbind, RDA_proj[1:2]))
TAB_RDA$variable <- factor(c(rep("RDA1", nrow(RDA_proj[[1]])), rep("RDA2", nrow(RDA_proj[[2]]))), levels = c("RDA1","RDA2"))
ggplot(data = TAB_RDA) + 
#geom_sf(data = admin, fill=gray(.9), size=0) +
  geom_raster(aes(x = x, y = y, fill = cut(value, breaks=seq(0, 1, length.out=10), include.lowest = T))) + 
  scale_fill_viridis_d(alpha = 0.8, direction = -1, option = "A", labels = c("Negative scores","","","","Intermediate scores","","","","Positive scores")) +
  #geom_sf(data = admin, fill=NA, size=0.1) +
  #coord_sf(xlim = c(-148, -98), ylim = c(35, 64), expand = FALSE) +
  xlab("Longitude") + ylab("Latitude") +
  guides(fill=guide_legend(title="Adaptive index")) +
  facet_grid(~ variable) +
  theme_bw(base_size = 11, base_family = "Times") +
  theme(panel.grid = element_blank(), plot.background = element_blank(), panel.background = element_blank(), strip.text = element_text(size=11))
```

<br>

<h2>

6.  Predicting local maladaptation: genomic offset

    </h2>

    <br>

<h4>6.1. Predicting future genomic offset</h4>

Once the genetic \~ environment relationship is characterized, it can be extrapolated to future environments to predict a potential shift in adaptive optimum induced by climate change.The RDA-based method to predict this future maladaptation is relatively simple. As done above, RDA can be used to predict the optimal adaptive genetic composition for each environmental pixel under consideration (Adaptive Index in Section 5), using both current and future environmental conditions. The difference between the two predictions provides an estimate of the change in genetic composition that would be required to track climate change.

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE, fig.align='center', fig.width=10}
## Function to predict genomic offset from a RDA model
source("../R/genomic_offset.R")

## Projecting the adaptive landscape after the change in environment 
res_RDA_proj <- genomic_offset(RDA = RDA_outliers, K = 2, env_pres = xx.ras.current, env_fut = xx.ras.future, range = NULL, method = "loadings", scale_env = NULL, center_env = NULL)

## Table global genetic offset predicted for 2050 and 2080
RDA_proj_offset <- as.data.frame(res_RDA_proj$Proj_offset_global, xy = TRUE)

## Projecting genomic offset on a map
library(wesanderson)
colors <- wes_palette("Zissou1", 100, type = "continuous")
ggplot(data = RDA_proj_offset) + 
  geom_raster(aes(x = x, y = y, fill = Global_offset), alpha = 1) + 
  scale_fill_gradientn(colours = colors, guide = guide_legend(title="Genomic offset", title.position = "top", title.hjust = 0.5, ncol = 1, label.position="right")) +
  xlab("Longitude") + ylab("Latitude") +
  theme_bw(base_size = 11, base_family = "Times") +
  theme(panel.grid = element_blank(), plot.background = element_blank(), panel.background = element_blank(), strip.text = element_text(size=11))
```
```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE, fig.align='center', fig.width=10}

diff.env <- sqrt(rowSums(as.data.frame((xx.ras.current[[1:2]] - xx.ras.future[[1:2]])^2)))
plot(diff.env, RDA_proj_offset$Global_offset)
fitness <- read.table("../data/fitness_futur.csv", header = T, sep = ",")

fitness.future <- rast(data.frame(x = rep(1:12, time = 12),
                                  y = rep(1:12, each = 12),
                                  aggregate(fitness[,2], by = list(ceiling(as.numeric(coord$x)), ceiling(as.numeric(coord$y))), mean)[,-c(1,2)]), 
                      type="xyz", 
                      crs = crs("epsg:4326"))

plot(log(as.data.frame(fitness.future)[,1])~RDA_proj_offset$Global_offset)

```

<br>

<h4>6.2. Predicting geographic genomic offset</h4>

A challenge associated with any predictive method is to find ways to validate the predictions. Here, we took advantage of the common garden experiment conducted in lodgepole pine to test our genomic offset predictions. We estimated a geographic genomic offset between the climate of each source population (based on the average between 1960 and 1990) and the climate of the garden where the seedlings were grown (in Vancouver, BC, Canada, averaging the years 2012 to 2015) and were then able to test the influence of the predicted genomic offset on the seedling fitness traits.

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE, fig.align='center'}
env <- row.names(scores(RDA_outliers, choices=c(1:2), display="bp"))

## Environmental variables for the period the seedlings were growing in the common garden (2012-2015)
env_garden <- read.table("./Data/ClimateData_VancouverGarden.csv", sep = ",", header = T)
env_garden <- env_garden[, env]
env_garden$MAR <- extract(ras_6190[[env]]$MAR, c(-123.250, 49.256))[2]
env_garden <- as.data.frame(scale(env_garden, center = center_env[env], scale = scale_env[env]))
env_garden <- colMeans(env_garden)

## Environmental variables for the source populations between 61 and 90
env_provenance <- data.frame(extract(ras_6190[[env]], Variables[,c("Longitude", "Latitude")]))
env_provenance <- as.data.frame(scale(env_provenance, center_env[env], scale_env[env]))
row.names(env_provenance) <- Variables[,"Population"]
```

Based on the adaptively enriched RDA space, we estimated a distance between each source population and the common garden climatic conditions.

```{r, message=FALSE, results='hide', eval=TRUE, fig.align='center'}
## Function to estimate genetic offset between provenance and garden  
source("./src/provgar_offset.R")

## Running the provenance to garden genetic offset function
provgar_offset <- provgar_offset(RDA = RDA_outliers, K = 2, env_garden = env_garden, env_provenance = env_provenance, weights = TRUE)
```

This geographic genomic offset can then be compared to different fitness traits in the garden to estimate the impact of this predicted maladaptation on seedling fitness. We can also compare the influence of genomic offset on fitness with the impact of a basic climate transfer distance estimated between each source population and the garden from the climatic variables only (using Mahalanobis distance).

```{r, message=FALSE, results='hide', eval=TRUE, fig.align='center'}
## Climate distance between provenances and garden
tabmaha <- as.data.frame(rbind(env_garden, env_provenance))
mahaclim <- mahalanobis(as.matrix(tabmaha), center = as.numeric(tabmaha[1,]), cov = cov(as.matrix(tabmaha)))

## Comparison climate transfer vs. genomic offset impact on fitness
TAB_comp <- data.frame(x = rep(c(mahaclim[-1], provgar_offset[-1]), 2), y = c(rep(traits$Height, 2), rep(traits$GthRate, 2)), method = rep(rep(c("Climate", "Genetics"), each = nrow(traits)), 2), variable = rep(c("Final height", "Growth rate"), each = 2*nrow(traits)))
ggplot(TAB_comp, aes(x=x, y=y)) +
  geom_point(shape=19, size = 2, alpha = .7) +
  geom_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1) +
  facet_grid(variable ~ method, scales = "free") +
  ylab("Scaled fitness trait value") + 
  xlab("Climate transfer distance                              Genomic offset") +
  theme_bw(base_size = 12, base_family = "Times") +
  theme(panel.grid = element_blank(), panel.background = element_blank())
```

```{r, message=TRUE, eval=TRUE}
## Quadratic regression statistical testing
summary(lm(traits$Height ~ poly(mahaclim[-1])))
summary(lm(traits$Height ~ poly(provgar_offset[-1])))
summary(lm(traits$GthRate ~ poly(mahaclim[-1])))
summary(lm(traits$GthRate ~ poly(provgar_offset[-1])))
```

**Notes on interpretation and best practices:** We found that genomic offset better explained the decrease in height and growth rate than the basic climate transfer distance, which confirms the great potential of genomic offset for selecting source population for management or conservation plans. As with the adaptive index (previous section), when validation data are not available, it is critical to avoid overinterpretation of genomic offset projections given that they are based on statistical associations only.
